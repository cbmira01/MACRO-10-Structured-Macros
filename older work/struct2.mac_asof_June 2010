;    UNIVERSAL  STRUC2  --  STRUCTURED PROGRAMMING MACROS



;;  STRUC2 -- A SET OF STRUCTURED PROGRAMMING MACROS FOR THE DECSYSTEM-10 ASSEMBLER.

;;  Struc2: C. Miracle, Louisville KY, June 2010
;;          cbmira01@louisville.edu
;;  
;;  This implementation was inspired by the original STRUCT code written  
;;      by ROBERT P. NIX  --  11/21/78. His original code can be found at 
;;      http://pdp-10.trailing-edge.com/decuslib10-08/index.html in the 
;;      DECUS library dcus:[43,50500]. Thanks, Robert!
;;

        COMMENT     |

                NOTES ON STRUC2 MACRO CALLS
        %STRUC 
            Use STRUC before any use of structure programming macro calls.


        %IF <condition>
          -- CODE --
        %ELSE
          -- CODE --
        %ENDIF


        %IF <condition> 
          -- CODE --
        %ENDIF


        %WHILE <condition>
          -- CODE --
        %ENDWHILE


        %REPEAT
          -- CODE --
        %UNTIL <condition>


       %FOR loop_variable, start, <condition>, increment
           -- CODE --
       %ENDFOR
            The loop variable must be supplied in user code; it is not defined
            by the loop structure, nor protected by it. The start and increment 
            values are actually memory locations, but can be made to appear as 
            literal values by use of the assembler literal brackets []. For 
            example, a FOR loop to count from 1 to 100 by 1 can be set up as: 
                LOOPV:  BLOCK 1
                    -- intervening code --
                %FOR LOOPV, [1], <LOOPV, LE, [100]>, [1]
                        -- loop code body --
                %ENDFOR


        %CASE
           %WHEN <condition> 
                -- CODE --

           %WHEN <condition> 
                -- CODE --

           %DEFAULT
                -- CODE --
        %ENDCASE
            When a WHEN case evaluates true, its case code is executed, then 
            a branch is taken to the end of the structure; code execution does 
            not "fall through" to the following WHEN. Only code in the first 
            matching WHEN case is executed. Any number of WHEN cases can be 
            defined. The DEFAULT case is optional, but if defined, may only be
            defined once and must be the final case in the CASE-ENDCASE 
            structure. DEFAULT case will execute if no other WHEN cases match. 


        %BREAK <condition>
        %CONTINUE <condition>
            BREAK and CONTINUE are legal only in the scope of WHILE, REPEAT or
            FOR loops. On condition resolved true, BREAK branches to the exit
            point of the loop; CONTINUE branches to the loopback point of the
            loop. BREAK and CONTINUE are optional, and can be used multiple 
            times in the scope of a loop structure.


                NOTES ON EVALUATION OF CONDITIONAL EXPRESSIONS
    <condition> is defined as   <TRUE>                              OR
                                <FALSE>                             OR
                                <A, COND, B>                        OR
                                <<condition>, AND, <condition>>     OR
                                <<condition>, OR, <condition>>      OR
                                <NOT, <condition>>

    COND is one of:  EQ  |  NE  |  GT  |  LT  |  GE  | LE
    A and B are general memory locations as defined in user code, or literal
    references (such as [9] or [102]). 
                    |       ; end of comment


        LALL


    ; Set a stack location to a given value. Base will be 
    ;   '.s' or '.b' for the STRUC2 application.
    DEFINE  %SKSET (BASE, LEVEL, VALUE) <
        BASE'LEVEL=VALUE
    >

    ; Purge an abandoned symbol, or just mark it abandoned 
    ;   for debugging purposes.
    DEFINE  %SKPUR (BASE, LEVEL) <
        PURGE BASE'LEVEL
        IFE <.ftpur>,<
            BASE'LEVEL=.purge
        >
    >

    ; Return a given stack location into the variable '.stacv'.
    DEFINE  %STACV (BASE, LEVEL) <
        .stacv=BASE'LEVEL
    >

    ; Push a given value onto the structure stack. Stack full causes 
    ;   the assembly to stop.
    DEFINE  %SPUSH (VALUE) <
        IFG <.sPtr-.sLim>,<
            PRINTX FATAL: the structure stack is full.
            END ; end assembly on fatal error
        >
        .sPtr=.sPtr+1
        %SKSET (.s,\.sPtr,VALUE)
    >

    ; Push a given value onto the logic stack. Stack full causes 
    ;   the assembly to stop.
    DEFINE  %LPUSH (VALUE) <
        IFG <.bPtr-.bLim>,<
            PRINTX FATAL: the logic stack is full.
            END ; end assembly on fatal error
        >
        .bPtr=.bPtr+1
        %SKSET (.b,\.bPtr,VALUE)
    >

    ; Pop the structure stack: return the top-of-stack value into '.stacv' 
    ;   and purge/abandon the location. A pop on an empty stack causes the 
    ;   assembly to stop.
    DEFINE  %SPOP <
        IFL <.sPtr>,<
            PRINTX FATAL: the structure stack is empty.
            END ; end assembly on fatal error
        >
        %STACV (.s,\.sPtr)
        %SKPUR (.s,\.sPtr)
        .sPtr=.sPtr-1
    >
    
    ; Pop the logic stack and purge/abandon the location. A pop
    ;   on an empty stack causes the assembly to stop. 
    DEFINE  %LPOP <
        IFN <.bPtr>,<
            PRINTX FATAL: the logic stack is empty.
            END ; end assembly on fatal error
        >
        %STACV (.b,\.bPtr)
        %SKPUR (.b,\.bPtr)
        .bPtr=.bPtr-1
    >
    
    ; Test the item at the top of the structure stack for one of the 
    ;   values given in LIST. If the item does not match one of the 
    ;   given values, then stop the assembly.
    DEFINE  %SMUST (LIST) <
        %SPOP
        IRP LIST,<
            IFN <.stacv-LIST>,<
                PRINTX FATAL: unexpected structure closure.
                END ; end assembly on fatal error
            >
        >
    >

    ; Resolve a jump forward to a following structure part. For insight into 
    ;   how this macro works, refer to DECsystem-10 Macro Assembler Reference 
    ;   Manual (AA-C780C-TB April 1978), page 3-46.
    DEFINE  %RFORW <
        .here=.                     ; Record the present location in the assembly.
        %SPOP                       ; Recover the source location of the jump.
        .ORG .stacv                 ; Set assembly pointer back to source location.
        JRST .here                  ; Insert a jump to the proper location.
        .ORG                        ; Resume the original line of assembly.
    >

    ; Resolve a number of jumps forward to a following structure part. The number
    ;   of jumps to resolve is at the top of stack.
    DEFINE  %RFORX <
        $SPOP
        REPEAT <.stacv>,<
            %RFORW
        >
    >

    ; Resolve a jump back to an earlier structure part, such as a loopback
    ;   address in WHILE, REPEAT, or FOR. 
    DEFINE %RBACK <
        %SPOP                       ; Recover the destination of the jump.
        JRST .stacv                 ; Insert a jump to the destination.
    >

    ; Parse and assemble the conditional code of a structure.
    DEFINE %LOGIC (COND, T, F, %T1, %F1)<
        CAME    0,9
          JRST 0
          JRST 1
    >

    ; Use before any user calls on structured macros, to initialize
    ;   workspace variables, manifest constants, and feature test 
    ;   symbols.
    DEFINE  %STRUCT <
            ; Manifest constants.
        .true=1
        .false=0
        .purge=^D-1         ; Marks an abandoned stack entry (if not purged).

            ; Name symbols for use in the structure stack.
        .if=^D1             ; IF
        .else=^D2           ; ELSE
        .while=^D3          ; WHILE
        .repea=^D4          ; REPEAT
        .for=^D5            ; FOR
        .case=^D6           ; CASE
        .when=^D7           ; WHEN
        .defal=^D8          ; DEFAULT

            ; Temporary workspace variables.
        .stacv=0            ; A structure stack value, usually top of stack.
        .lpbak=0            ; A structure loopback destination requiring resolution.
        .here=0             ; A current value of the assembler location counter.
        .temp1=0            ; Temporary save areas during stack edits.
        .temp2=0
        .temp3=0

        .sPtr=-1            ; Structure stack pointer and limit.
        .sLim=^O7777        ;   0-7777 octal allows for 4096 symbols.
 
        .bPtr=-1            ; Logic stack pointer and limit.
        .bLim=^O7777        ;   0-7777 octal allows for 4096 symbols.

            ; Feature tests and debug symbols.
        .ftpur=.false       ; Set to .true to purge abandoned stack symbols (normal).
                            ; Set to .false to retain abandoned stack symbols (debug).

        .ftfrc=0            ; Set to  0 for normal operation.
                            ; Set to -1 to force all final conditional evaluations to FALSE.
                            ; Set to  1 to force all final conditional evaluations to TRUE.
    >

    DEFINE  %IF (UCOND, %T, %F) <
        %LOGIC (UCOND %T, %F)       ; Dump the conditional logic here.
      %F:                           ; 'IF false' jump must be resolved later.
      %T:                           ; 'IF true' code follows this label.
        %SPUSH %F                   ; Unresolved jump to ELSE or structure exit.
        %SPUSH .if                  ; Open an IF activation frame.
    >

    DEFINE  %ELSE (%ELS, %END) <
        %SMUST <.ifNam>             ; Expect to be in an IF.
      %END:                         ; Jump to ENDIF.
      %ELS:                         ; 'ELSE code' follows this label.
        %RFORW                      ; Forward resolve 'IF false' jump to %ELS.
        %SPUSH %END                 ; Unresolved jump to structure exit.
        %SPUSH .else                ; Open an ELSE activation frame.
            ; The IF activation frame has been consumed at this point.
    >

    DEFINE  %ENDIF (%END) <
        %SMUST <.if, .else>         ; Expect to be in either IF or ELSE.
      %END:                         ; Structure exit point.
        %RFORW                      ; Resolve structure exit jumps from 'IF false' or 'ELSE %END'.
            ; The IF or ELSE activation frame has been consumed at this point.
    >

    DEFINE  %WHILE (UCOND, %T, %F) <
        .lpbak= .                   ; Note the WHILE loopback location.
        %LOGIC (UCOND %T, %F)       ; Dump the conditional logic here.
      %F:                           ; 'False' jump must be resolved later.
      %T:                           ; 'WHILE true' code follows this label.
        %SPUSH %F                   ; Unresolved jump to structure exit.
        %SPUSH 1                    ; Only one structure exit jump to resolve for now.
        %SPUSH .lpbak               ; Unresolved destination to loopback address.
        %SPUSH .while               ; Open a WHILE activation frame.
    >

    DEFINE  %ENDWHILE (%BACK, %END) <
        %SMUST <.while>             ; Expect to be in a WHILE.
      %BACK:                        ; Loop back to beginning of WHILE
        %RBACK                      ; Resolve %BACK to loopback address.
      %END:                         ; Structure exit point.
        %RFORX                      ; Resolve all structure exit jumps (including BREAKs).
            ; The WHILE activation frame has been consumed at this point.
    >

    DEFINE  %REPEAT <
        .lpbak= .
        %SPUSH 0                    ; No structure exit jumps to resolve (for now).
        %SPUSH .lpbak
        %SPUSH .repea
    >

    DEFINE  %UNTIL      (UCOND, %T, %F) <
        %SMUST <.repea> 
        %LOGIC (UCOND, T, F)
      %F:
        %RBACK
      %T:
        %RFORX
    >   

    DEFINE  %FOR        (LOOPV, START, UCOND, INCR, %T, %F) <
            ; Operations to set VAR = start
        movem %SAVE
        move START
        movem VAR
        move %SAVE
        JRST ONETME                 ; One-time jump into structure body.
      %SAVE: BLOCK 1                ; Place to save register 0 for loop operations.
        .lpbak= .
            ; Operations to set VAR = VAR + incr
        movem %SAVE
        move INCR
        addm VAR
        move %SAVE
        %LOGIC (UCOND, T, F)
      %F:
      %T:
      ONETME:
        %SPUSH %F
        %SPUSH 1 
        %SPUSH .lpbak
        %SPUSH .for
    >

    DEFINE  %ENDFOR     (%BACK, %END) <
        %SMUST <.for> 
      %BACK:
        %RBACK
      %END:
        %RFORX
    > 

    DEFINE  %CASE <
        %SPUSH 0                    ; No more structure exit jumps to resolve.
        %SPUSH .case1               ; Open a virgin CASE activation frame.
    >

    DEFINE  %WHEN       (UCOND, %T, %F, %ENTRY, %END) <
        %SMUST <.case1, .case2> 
            ; Frame type .case1 has never seen a WHEN clause before now. The chain
            ;   of WHEN clauses begins here with a special WHEN which does not
            ;   have to guard a previous WHEN's branch to structure end point.
        IFE <.stacv-.case1>,<
            %LOGIC (UCOND, T, F)
          %F:                       ; 'False' continues to the next WHEN clause.
          %T:                       ; 'True' runs the code body in this WHEN.
        >
            ; Frame type .case2 knows that the chain of WHEN clauses should continue,
            ;   and provide a jump to structure end for the previous WHEN.
        IFE <.stacv-.case2>,<
          %END:                     ; Allows the preceding WHEN to branch to structure end.
          %ENTRY:                   ; Flow from 'false' brach in previous WHEN.
            %RFORW
            %LOGIC (UCOND, T, F)
          %F:                       ; 'False' continues to the next WHEN.
          %T:                       ; 'True' runs the code body in this WHEN.
            %SPUSH %END             ; Stack another structure exit jump to resolve.
        >
        %SPUSH %F                   ; Stack a link to next WHEN's logic entry point.
        %SPUSH .case2               ; The WHEN chain continues.
    >

    DEFINE  %DEFAULT    (%ENTRY, %END) <
            ; DEFAULT is just a WHEN without a logic block.
        %SMUST <.case1, .case2> 
        IFE <.stacv-.case2>,<
          %END:                     ; Allows the preceding WHEN to branch to structure end.
          %ENTRY:                   ; Flow from 'false' brach in previous WHEN.
            %RFORW
            %SPUSH %END             ; Stack another structure exit jump to resolve.
        >
        %SPUSH .case3               ; Prevent any more following WHEN clauses.
    >

    DEFINE  %ENDCASE    ()  <
        %SMUST <.case1, .case2, .case3>    
        %RFORX                      ; Handle all structure exit jumps.
    >

    DEFINE  %BREAK      (UCOND, %T, %F) <
        %SMUST <.while, .repea, .for> 
        %LOGIC (UCOND, T, F)
      %T:
      %F:
        %SPOP                       ; Prepare the loop activation frame for an edit.
            .temp1=.stacv           ;   Activation frame code...
        %SPOP
            .temp2=.stacv           ;   Loopback address...
        %SPOP
            .temp3=.stacv           ;   Old count of structure exit jumps...
        %SPUSH %T                   ; Insert another structure exit jump to resolve.
            .temp3= .temp3+1        ; 
        %SPUSH .temp3               ; Store the new count of structure exit jumps.
        %SPUSH .temp2               ; Restore the original loopback address.
        %SPUSH .temp1               ; Restore the loop activation frame code.
    >

    DEFINE  %CONTINUE   (UCOND, %T, %F) <
        %SMUST <.while, .repea, .for>
            .temp1= .stacv          ; Remember the activation frame code.
        
        %LOGIC (UCOND, T, F)
      %T:
        %RBACK                      ; Resolve loopback address for CONTINUE.
        %SPUSH .stacv               ; Restore the loopback address.
        %SPUSH .temp1               ; Restore the loop activation frame code.
      %F:
    >


        %STRUCT

        Z 0,1(0)

        ;  ********** Simple IF
        %IF t
            Z 0,2(0)
            Z 0,2(0)
        %ELSE
            Z 0,3(0)
            Z 0,3(0)
        %ENDIF

        ;  ********** Simple WHILE
        %WHILE t
            Z 1,1(0)
            Z 1,1(0)
        %ENDWHILE

        ;  ********** Simple REPEAT
        %REPEAT
            Z 2,1(0)
            Z 2,1(0)
        %UNTIL t

        ;  ********** Simple FOR
        %FOR VAR, [1], t, [100]
            Z 3,1(0)
            Z 3,1(0)
        %ENDFOR

        ;  ********** Simple CASE
        %CASE
            %WHEN t
                Z 4,1(0)
                Z 4,1(0)
                Z 4,1(0)
            %WHEN t
                Z 4,2(0)
                Z 4,2(0)
            %WHEN t
                Z 4,3(0)
            %DEFAULT
                Z 4,4(0)
        %ENDCASE

        ;  ********** Nested structures 5 deep
        %WHILE t
            Z 1,1(0)
            %CASE
                %WHEN t
                    Z 4,1(0)
                    %IF t
                        Z 0,2(0)
                        %FOR VAR, [1], t, [100]
                            Z 3,1(0)
                            %REPEAT
                                Z 2,1(0)
                                Z 2,1(0)
                            %UNTIL t
                            Z 3,1(0)
                        %ENDFOR
                        Z 0,2(0)
                    %ELSE
                        Z 0,3(0)
                        Z 0,3(0)
                    %ENDIF  
                    Z 4,1(0)
                %WHEN t
                    Z 4,2(0)
                    Z 4,2(0)
                %WHEN t
                    Z 4,3(0)
                %DEFAULT
                    Z 4,4(0)
                %ENDCASE
            Z 1,1(0)
        %ENDWHILE        

        ;  ********** Loops with BREAK and CONTINUE
        %WHILE t
            Z 1,1(0)
            %BREAK t
            %BREAK t
            %CONTINUE t
            %BREAK t
            %BREAK t
            %REPEAT
                Z 2,1(0)
                %CONTINUE t
                Z 2,1(0)
                %FOR VAR, [1], t, [100]
                    Z 3,1(0)
                    %BREAK t
                    %CONTINUE t
                    Z 3,1(0)
                %ENDFOR
                %BREAK t
                %CONTINUE t
                %BREAK t
                Z 2,1(0)
            %UNTIL t
            %CONTINUE t
            %BREAK t
            %BREAK t
            %CONTINUE t
            Z 1,1(0)
        %ENDWHILE

        ;  ********** Nested CASE
        %CASE
            %WHEN t
                Z 4,1(0)
                %CASE
                    %WHEN t
                        Z 4,1(0)
                    %DEFAULT
                        Z 4,4(0)
                %ENDCASE
                Z 4,1(0)
            %WHEN t
                Z 4,2(0)
                %CASE
                    %WHEN t
                        Z 4,1(0)
                        Z 4,1(0)
                        Z 4,1(0)
                    %WHEN t
                        Z 4,2(0)
                        Z 4,2(0)
                %ENDCASE
                Z 4,2(0)
            %WHEN t
                Z 4,3(0)
            %DEFAULT
                Z 4,4(0)
        %ENDCASE

        COMMENT     |

                NOTES ON STACKS, STACK LIMITS, ACTIVATION FRAMES
        The 'stacks' mentioned in this file are defined as MACRO-36 assembler
        symbols, not the pushdown stack as maintained during PDP-10 processor 
        execution. There are two symbolic stacks for the STRUC2 application: 
        a structure stack, used to keep track of programming structure 
        invocations, and a logic stack, used to help parse and serialize code 
        needed to evaluate logical conditions. Each stack has a pointer symbol 
        and a limit symbol, defined in the %STRUC macro.

        The structure stack is based on symbol '.s', and keeps track of 
        'activations' of structures with 'activation codes'. The purpose of 
        this is so that structures can be nested without interfering with each 
        other, and so that branch resolutions can be applied to the proper 
        invocation level. Other entities residing on the structure stack are
        forward and backward jumps requiring resolution in other structure
        clauses, and, if BREAK is used in a loop, a count of items on the stack
        requiring forward resolution.

        The logic stack...

        In general, user code should avoid the use of symbols such as '.snnnn'
        or '.bnnnn', where 'nnnn' is in the range '0' to '7777'. Other symbols
        to avoid are listed in the %STRUC macro. The %STRUC macro has debug
        feature tests to dump the structure stack and force logic evaluations.
        

                NOTES ON USAGE OF STRUCTURED PROGRAMMING MACROS
        Successful usage of the macro calls mainly involves closing a structure
        properly with the corresponding END part. Oddball compositions of macro
        calls are certainly possible, but not recommended. Assembly will fail at
        the first occurence of an improperly closed structure.

        The macro calls do not support 'local variables', so this must be the
        responsibility of user code. In particular, loop variables used in the 
        FOR loop are not 'local' to the FOR, are not 'protected in an invocation
        frame', so beware.

        The STRUC2 application uses a number of elementary macro definitions
        which constitute a general language for the manipulation of symbolic 
        stacks, and could conceivably be used in user code. Some possible 
        extensions to STRUC2 might involve local variables, procedure calls,
        or data structures.

        No registers are used by STRUC2 macros, except register 0 (briefly) in 
        the FOR structure. No use is made of execution-time pushdown stacks.


                NOTES ON COMPILING AND USING STRUCTURED PROGRAMMING MACROS
        STRUC2 structured programming macros are assembled into a UNIVERSAL 
        file, then SEARCHed by user code.

        To assemble STRUC2.MAC:
            .R MACRO
            *STRUCT.MAC
            ^C

        This process will produce STRUC2.UNV, structured programming macros 
        ready for use. STRUC2.UNV can be copied to the system UNV: ersatz 
        device for use by all users on the system.

        In user code, a SEARCH line should be included in MACRO code, typically:
                SEARCH		STRUC2
        along with whatever other UNIVERSAL files are needed for the application:
                SEARCH		JOBDAT, MACTEN, UUOSYM, STRUC2
        For more information on UNIVERSAL files and SEARCHing, refer to the MACRO
        assembler manual, page 3-64 and page 3-75ff.


                NOTES ON FLOW OF CONTROL THROUGH ASSEMBLED CODE
        The structured programming macros help lay out the programming 
        structures for serial execution by the PDP-10 processor. Following is a
        rough sketch of how the structured code is assembled for the processor:

            IF-ENDIF
        If (!condition) GOTO END
            -- true code --
        END:

            IF-ELSE-ENDIF
        If (!condition) GOTO ELSE
            -- code --
            GOTO END
        ELSE:
            -- code --
        END:

            WHILE-ENDWHILE
        LOOP: If (!condition) GOTO END
            -- code --
        GOTO LOOP
        END:

            REPEAT-UNTIL
        LOOP:
           -- code --
        If (!condition) GOTO LOOP
        END:

            FOR-ENDFOR     %FOR VAR, [start], <condition>, [increment]
        set VAR = start
        GOTO ONE_TIME:
        LOOP:
            set VAR = VAR + increment
            If (!condition) GOTO END
        ONE_TIME:
           -- code --
        GOTO LOOP
        END:

            CASE-ENDCASE
        If (!condition_1) GOTO WHEN_2
              -- code --
           GOTO END

        WHEN_2: If (!condition_2) GOTO WHEN_3
              -- code --
           GOTO END

           [...and so on...]

        WHEN_N: If (!condition_N) GOTO DEFAULT
              -- code --
           GOTO END

        DEFAULT: 
               -- code --
        END:

            BREAK
        If (condition) GOTO END

            CONTINUE 
        If (condition) GOTO LOOP

                |    ; end of comment

            END
