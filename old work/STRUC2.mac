
                             COMMENT |

    STRUC2 -- A SET OF STRUCTURED PROGRAMMING MACROS FOR DECSYSTEM-10 ASSEMBLER.
            by Calvin Miracle, Louisville KY

        STRUC2 was developed to allow a programmer working in DecSystem-10 macro
        assembler an easier way to express code. In particular, it was developed
        to allow me to better build a command-string recognizer for another 
        assembler project. STRUC2 was designed to have as little impact as 
        possible on user code. STRUC2 does not use the user's stack. When STRUC2 
        requires working registers, it protects user register values.

        This implementation of structured programming macros was inspired by the 
        original STRUCT macros written by Robert P. Nix, 21 November 1978. His 
        original code can be found in the DECUS-10 library 
        dcus:[43,50500], http://pdp-10.trailing-edge.com/decuslib10-08/index.html 
        Thank you, Robert!

        See the accompanying file STRUC2.TXT for more information and credits.

                             | ; end comment

    UNIVERSAL STRUC2 

    ; Set a stack location to a given value. Symbolic 'base' will be '.s' for 
    ;   the STRUC2 macros.
    DEFINE  $SET (BASE, LEVEL, VALUE) <
        BASE'LEVEL=VALUE
    >

    ; Purge an abandoned symbol, or just mark it abandoned for debugging purposes.
    DEFINE  $PURGE (BASE, LEVEL) <
        PURGE BASE'LEVEL
        IFE <.ftpur-.false>,<
            BASE'LEVEL=.purge
        >
    >

    ; Return a given stack location into the variable '.getval'.
    DEFINE  $GETVAL (BASE, LEVEL) <
        .getval=BASE'LEVEL
    >

    ; Push a given value onto the structure stack. A push onto a stack already 
    ;   at its limit causes assembly to stop.
    DEFINE  $PUSH (VALUE) <
        IFG <.sPtr-.sLim>,<
            PRINTX STRUC2 ERROR: PUSH attempted on a full stack.
            END  
        >
        .sPtr=.sPtr+1
        $SET (.s,\.sPtr,VALUE)
    >

    ; Pop the structure stack, return the top-of-stack value into '.getval' and 
    ;   purge/abandon the location. A pop on an empty stack causes assembly to 
    ;   stop.
    DEFINE  $POP <
        IFL <.sPtr>,<
            PRINTX STRUC2 ERROR: POP attempted on an empty stack.
            END 
        >
        $GETVAL (.s,\.sPtr)
        $PURGE (.s,\.sPtr)
        .sPtr=.sPtr-1
    >
    
    ; Test the item at the top of the structure stack for one of the values in 
    ;   LIST. If the item does not match one of the given values, then set a flag
    ;   which may be used to stop the assembly.
    DEFINE  $MUSTBE (LIST) <
        $POP
        .mbflag=.false
        IRP LIST,<
            IFE <.getval-LIST>,< .mbflag=.true >
        >

        IFE <.mbflag-.false>,<
            ; PRINTX STRUC2 ERROR: unexpected symbol found on the stack.
            ; END 
        >
    >

    ; Resolve a jump forward to a following structure part. For insight into how 
    ;   this macro works, refer to [DMARM] page 3-46.
    DEFINE  $RFORW <
        .here=.                     ; Record the current location in the assembly.
        $POP                        ; Get the source location of a jump.
        .ORG .getval                ; Set the assembly pointer back to the source location.
        jrst .here                  ; Insert a jump to the forward location.
        .ORG                        ; Resume the original line of assembly.
    >

    ; Resolve a number of jumps forward to a following structure part. The 
    ;   number of jumps to resolve is at the top of stack.
    DEFINE  $RFORX <
        $POP
        REPEAT <.getval>,<
            $RFORW
        >
    >

    ; Resolve a jump back to an earlier structure part, such as a loopback 
    ;   address in $WHILE, $REPEAT, or $FOR. 
    DEFINE $RBACK <
        $POP                        ; Recover the destination of the jump.
        jrst .getval                ; Insert a jump to the destination.
    >

    ; Fully parse a conditional expression into an RPN symbol string.
    DEFINE $PARSE (T1,T2,T3) <
        .plvl=.plvl+1               ; Track parse level for end-of-string symbol.

        IFIDN <T2><AND>,<
            $PARSE T1
            $PARSE T3
            exp .op,,$$OPAN
        >
        IFIDN <T2><OR>,<
            $PARSE T1
            $PARSE T3
            exp .op,,$$OPOR
        >
        IFIDN <T1><NOT>,<
            exp 0                   ; Dummy argument to enforce RPN 2-arity.
            $PARSE T2
            exp .op,,$$OPNO
        >
        IFIDN <T2><XOR>,<
            $PARSE T1
            $PARSE T3
            exp .op,,$$OPXO
        >
        IFIDN <T2><EQV>,<
            $PARSE T1
            $PARSE T3
            exp .op,,$$OPQV
        >
        IFIDN <T2><IMPL>,<
            $PARSE T1
            $PARSE T3
            exp .op,,$$OPMI
        >
        IFIDN <T2><EQ>,<
            $PARSE T1
            $PARSE T3
            exp .op,,$$OPEQ
        >
        IFIDN <T2><NE>,<
            $PARSE T1
            $PARSE T3
            exp .op,,$$OPNE
        >
        IFIDN <T2><GT>,<
            $PARSE T1
            $PARSE T3
            exp .op,,$$OPGT
        >
        IFIDN <T2><LT>,<
            $PARSE T1
            $PARSE T3
            exp .op,,$$OPLT
        >
        IFIDN <T2><GE>,<
            $PARSE T1
            $PARSE T3
            exp .op,,$$OPGE
        >
        IFIDN <T2><LE>,<
            $PARSE T1
            $PARSE T3
            exp .op,,$$OPLE
        >
        IFIDN <T1><TRUE>,<
            exp .true
        >
        IFIDN <T1><FALSE>,<
            exp .false
        >

        .plvl=.plvl-1
        IFE<.plvl>,<
            exp     .ec                 ; Signal end of RPN string.
        >
    >

    ; Implementation of structure condition code: supply the RPN engine with 
    ;   TRUE and FALSE branch points, locally assemble a conditional expression 
    ;   into an RPN string, then submit the string to the RPN engine.
    DEFINE $LOGIC (T, F, %string) <
                    movem   1, $$SAVR+1
                    movei   1, T        ; Supply TRUE return point.
                    move    1, $$TRUE  
                    movei   1, F        ; Supply FALSE return point.
                    move    1, $$FALS
                    movei   1, %string  ; Supply beginning of RPN string.
                    jrst    $$REVL      ; Branch into the expression evaluator.
        %string:                        ; Point to an eventual RPN string.
    >

    ; Use the $STRUC macro before any user calls on structured macros, to 
    ;   initialize workspace variables, manifest constants and feature test 
    ;   symbols, and to provide code to evaluate conditional expressions.
    DEFINE  $STRUC <
            ; Jump around the body of this macro.
                    jrst    $$JOVR

            ; Manifest constants.
        .true=1
        .false=0
        .mbflag=.false              ; A flag for $MUSTBE processing.

            ; Name symbols for use in the structure stack.
        .symbol=707070              ; A distinctive symbol prefix for listings.
        .purge= .symbol,,^O777777   ; Marks an abandoned stack entry.
        .if=    .symbol,,^O1        ; IF
        .else=  .symbol,,^O2        ; ELSE
        .while= .symbol,,^O3        ; WHILE
        .repeat=.symbol,,^O4        ; REPEAT
        .for=   .symbol,,^O5        ; FOR
        .case1= .symbol,,^O6        ; CASE (virgin, never saw a WHEN)
        .case2= .symbol,,^O7        ; CASE (in a chain of WHENs)
        .case3= .symbol,,^O10       ; CASE (handling a DEFAULT)
        .when=  .symbol,,^O11       ; WHEN

            ; Workspace variables.
        .getval=0                   ; A stack value, usually top of stack.
        .lpbak= 0                   ; A loopback destination requiring resolution.
        .here=  0                   ; A current value of the location counter.
        .plvl=  0                   ; Parse level of conditional expression.

            ; Temporary save areas during stack edits.
        .temp1=0 
        .temp2=0
        .temp3=0

            ; Structure stack pointer and limit.
        .sPtr=-1                    ; Symbol .s0 is the first used location in the stack.
        .sLim=^O7777                ;   .s0 to .s7777 (octal) allows for 4096 symbols.
 
            ; The following bit prefix markers are used to help the RPN engine 
            ;   during evaluation of conditional expressions. 
        .ec=^O100000,,0             ; RPN string end code.
        .op=^O200000                ; Indicates 'an operator'.

            ; Feature test/debug symbols.
        .ftpur=.false           ; Set .true to purge abandoned stack symbols (normal operation).
                                ; Set .false to retain abandoned stack symbols (debug).

        .ftfrc=0                ; Set  0 for normal evaluation of conditional expressions.
                                ; Set -1 to force all conditionals to evaluate FALSE.
                                ; Set  1 to force all conditionals to evaluate TRUE.
        
        .ftrpn=.true            ; Set .true for adequate RPN stack size (normal operation).
                                ; Set .false to force small RPN stack size (debug).


            ; Here is the RPN evaluator for conditional expressions. The heart 
            ;   of the evaluator, the "Postfix Algorithm", is descibed in [WIKI].
            ;   This evaluator is 2-arity, meaning it processes two-argument 
            ;   logic operators and leaves the result on the stack. The final 
            ;   value on the stack is the logic value of the overall RPN string 
            ;   (which is a compiled version of the structure condition
            ;   expression).
            ;
            ; On entry, the TRUE and FALSE link addresses will have been 
            ;   initialized, with register 1 pointing to the RPN string. 
            ;   Registers required by the evaluator are saved on entry and 
            ;   restored on exit, after which an indirect branch will be taken 
            ;   to the proper result link. 
            ;
            ; Error conditions detected are 'too many values on the RPN stack', 
            ;   and 'too few values on the RPN stack'. Runtime errors will report 
            ;   to the TTY and cause the job to halt.

            ; Provision the RPN engine runtime stack.
        $$SLEN=^D100                ; Adequate stack size.
        IFE <.ftrpn-.true>,<        ; Provision for an inadequate stack.
            $$SLEN=^D5
        >
        $$RSTK:     block   $$SLEN

        $$SAVR:     block   ^D16    ; Temporary storage for user registers.
        $$REVL:     movem   ^O0,   $$SAVR+^O0   ; Save working registers...
                    ; movem   ^O1,  $$SAVR+^O1  ; Accounted for in $LOGIC macro call.
                    movem   ^O2,   $$SAVR+^O2 
                    movem   ^O3,   $$SAVR+^O3      
                    movem   ^O4,   $$SAVR+^O4  
                    movem   ^O5,   $$SAVR+^O5  
                    movem   ^O6,   $$SAVR+^O6 
                    movem   ^O7,   $$SAVR+^O7 
                    movem   ^O10,  $$SAVR+^O10 
                    movem   ^O11,  $$SAVR+^O11 
                    movem   ^O12,  $$SAVR+^O12 
                    movem   ^O13,  $$SAVR+^O13 
                    movem   ^O14,  $$SAVR+^O14 
                    movem   ^O15,  $$SAVR+^O15 
                    movem   ^O16,  $$SAVR+^O16 
                    movem   ^O17,  $$SAVR+^O17

                    move    ^O17, [IOWD $$SLEN,$$RSTK]
                    
            ; While there are tokens left in the RPN symbol string...
        $$LOOP:     move    ^O2, ^O1
                    camn    ^O2, [.ec]
                      jrst  $$REND

            ; ...consider the current token in register 2. If it's not an 
            ;   operator, then it's either a logic value (0 or 1) or a memory
            ;   reference (high-order halfword = 0); push it onto the stack and 
            ;   go back for another.
                    hlrzm   ^O2, ^O3    
                    came    ^O3, [.op]
                      jrst  $$RSLT

            ; Each operator takes takes two arguments. So error if there are fewer 
            ;   than two values on the stack.
        $$ANOP:     hlrem   ^O17, ^O3
                    camge   ^O3, [-$$SLEN+^O2]                    
                      jrst  $$ETFV

            ; The sequence of evaluation is 'register_3 OPERATOR register_4'. For 
            ;   NOT, the operation will be performed on register 4, since register 
            ;   3 will contain an arity-dummy value.
            
            ; Pop two argument values from the stack and branch to the proper op 
            ;   evaluation routine. 
                    pop     ^O17, ^O4           ; Right-hand value.
                    pop     ^O17, ^O3           ; Left-hand value.
                    hrrzs   ^O2               ; Strip .op code from the branch address.
                    jrst    @^O2

        $$OPAN:     move    ^O2, ^O3
                    and     ^O2, ^O4
                    jrst    $$RSLT

        $$OPOR:     move    ^O2, ^O3
                    ior     ^O2, ^O4
                    jrst    $$RSLT

        $$OPNO:     setcm    ^O2, ^O4                    
                    jrst    $$RSLT

        $$OPXO:     move    ^O2, ^O3
                    xor     ^O2, ^O4
                    jrst    $$RSLT

        $$OPQV:     move    ^O2, ^O3
                    eqv     ^O2, ^O4
                    jrst    $$RSLT

        $$OPMI:     move    ^O2, ^O3
                    orcm    ^O2, ^O4
                    jrst    $$RSLT      

        $$OPEQ:     move    ^O2, [.true]
                    came    ^O3, ^O4
                      move    ^O2, [.false]
                    jrst    $$RSLT

        $$OPNE:     move    ^O2, [.true]
                    camn    ^O3, ^O4
                      move    ^O2, [.false]
                    jrst    $$RSLT

        $$OPGT:     move    ^O2, [.true]
                    camg    ^O3, ^O4
                      move    ^O2, [.false]
                    jrst    $$RSLT

        $$OPLT:     move    ^O2, [.true]
                    caml    ^O3, ^O4
                      move    ^O2, [.false]
                    jrst    $$RSLT

        $$OPGE:     move    ^O2, [.true]
                    camge   ^O3, ^O4
                      move    ^O2, [.false]
                    jrst    $$RSLT

        $$OPLE:     move    ^O2, [.true]
                    camle   ^O3, ^O4
                      move    ^O2, [.false]
                    ; jrst    $$RSLT

            ; Push the returned result back onto the stack and continue.
        $$RSLT:     push    ^O17, ^O2
                    addi    ^O1, ^O1            ; Advance the RPN string pointer.
                    jrst    $$LOOP

            ; If there is only one value left on the stack...
        $$REND:     hlrzm   ^O17, ^O3
                    came    ^O3, [-$$SLEN+^O1]
                      jrst $$ETMV

            ; ...then that value is the result of the RPN calculation, or the 
            ; result may be forced by a feature-test flag.
                    pop     ^O17, ^O2
        IFL <.ftfrc>,<
                    move    ^O2, [.false]
        >
        IFG <.ftfrc>,<
                    move    ^O2, [.true]
        >

            ; Restore user registers and return to structure code.
                    move    ^O0,  $$SAVR+^O0 
                    move    ^O1,  $$SAVR+^O1 
                    ; move   ^O2,   $$SAVR+^O2 
                    move    ^O3,   $$SAVR+^O3      
                    move    ^O4,   $$SAVR+^O4  
                    move    ^O5,   $$SAVR+^O5  
                    move    ^O6,   $$SAVR+^O6 
                    move    ^O7,   $$SAVR+^O7 
                    move    ^O10,  $$SAVR+^O10 
                    move    ^O11,  $$SAVR+^O11 
                    move    ^O12,  $$SAVR+^O12 
                    move    ^O13,  $$SAVR+^O13 
                    move    ^O14,  $$SAVR+^O14 
                    move    ^O15,  $$SAVR+^O15 
                    move    ^O16,  $$SAVR+^O16 
                    move    ^O17,  $$SAVR+^O17

                    came    ^O2, [.true]
                      jrst  $$JF
                    move   ^O2,   $$SAVR+^O2 
                    jrst    @$$TRUE
            $$JF:   move   ^O2,   $$SAVR+^O2 
                    jrst    @$$FALS

        $$TRUE:     block   1       ; Indirect link back to structure TRUE code.
        $$FALS:     block   1       ; Indirect link back to structure FALSE code.

            ; Handle errors here.
        $$ETMV:     outstr  [asciz /STRUC2 error: Too many values on the RPN stack./]
                    jrst    $$EXIT
        $$ETFV:     outstr  [asciz /STRUC2 error: Too *few* values on the RPN stack./]
                    ; jrst    $$EXIT
        $$EXIT:     reset
                    exit

            ; A branch here makes the $STRUC body unreachable in-line.
        $$JOVR:
    >

    DEFINE  $IF (UCOND, %T, %F) <
        $LOGIC %T, %F               ; Dump the conditional logic here.
        $PARSE UCOND                ; Parse the conditional expression.
      %F:  exp 0                    ; 'IF false' jump must be resolved later.
      %T:                           ; 'IF true' code follows this label.
        $PUSH %F                    ; Unresolved jump to ELSE or structure exit.
        $PUSH .if                   ; Open an IF activation frame.
    >

    DEFINE  $ELSE (%ELS, %END) <
        $MUSTBE <.if>               ; Expect to be in an IF.
            IFE <.mbflag-.false>,<
                PRINTX STRUC2 ERROR: ELSE was expecting IF.
                END  
            >
      %END:  exp 0                  ; Jump to ENDIF.
      %ELS:                         ; 'ELSE code' follows this label.
        $RFORW                      ; Forward resolve 'IF false' jump to %ELS.
        $PUSH %END                  ; Unresolved jump to structure exit.
        $PUSH .else                 ; Open an ELSE activation frame.
            ; The IF activation frame has been consumed at this point.
    >

    DEFINE  $ENDIF (%END) <
        $MUSTBE <.if,.else>         ; Expect to be in either IF or ELSE.
            IFE <.mbflag-.false>,<
                PRINTX STRUC2 ERROR: ENDIF was expecting IF or ELSE.
                END 
            >
      %END:                         ; Structure exit point.
        $RFORW                      ; Resolve exit jumps from 'IF false' or 'ELSE %END'.
            ; The IF or ELSE activation frame has been consumed at this point.
    >

    DEFINE  $WHILE (UCOND, %T, %F) <
        .lpbak= .                   ; Note the WHILE loopback location.
        $LOGIC %T, %F               ; Dump the conditional logic here.
        $PARSE UCOND                ; Parse the conditional expression.
      %F:   exp 0                   ; 'False' jump must be resolved later.
      %T:                           ; 'WHILE true' code follows this label.
        $PUSH %F                    ; Unresolved jump to structure exit.
        $PUSH 1                     ; Only one structure exit jump to resolve for now.
        $PUSH .lpbak                ; Unresolved destination to loopback address.
        $PUSH .while                ; Open a WHILE activation frame.
    >

    DEFINE  $ENDWHILE (%BACK, %END) <
        $MUSTBE <.while>            ; Expect to be in a WHILE.
            IFE <.mbflag-.false>,<
                PRINTX STRUC2 ERROR: ENDWHILE was expecting WHILE.
                END  
            >
      %BACK:  exp 0                 ; Loop back to beginning of WHILE
        $RBACK                      ; Resolve %BACK to loopback address.
      %END:                         ; Structure exit point.
        $RFORX                      ; Resolve all exit jumps (including BREAKs).
            ; The WHILE activation frame has been consumed at this point.
    >

    DEFINE  $REPEAT <
        .lpbak= .
        $PUSH 0                     ; No structure exit jumps to resolve for now.
        $PUSH .lpbak
        $PUSH .repeat
    >

    DEFINE  $UNTIL (UCOND, %T, %F) <
        $MUSTBE <.repeat> 
            IFE <.mbflag-.false>,<
                PRINTX STRUC2 ERROR: UNTIL was expecting REPEAT.
                END  
            >
        $LOGIC %T, %F 
        $PARSE UCOND
      %F:   exp 0
        $RBACK
      %T:
        $RFORX
    >   

    DEFINE  $FOR (LOOPV, START, UCOND, INCR, %T, %F, %FIRST) <
            ; Operations to set LOOPV = start
                    movem   1, $$SAVR+1
                    move    1, START
                    movem   1, LOOPV
                    move    1, $$SAVR+1
                    jrst    %FIRST          ; First iteration is always performed.

        .lpbak= .
            ; Operations to set LOOPV = LOOPV + incr
                    movem   1, $$SAVR+1
                    move    1, INCR
                    addm    1, LOOPV
                    move    1, $$SAVR+1
        $LOGIC %T, %F 
        $PARSE UCOND
      %F:   exp 0
      %T:  %FIRST:
        $PUSH %F
        $PUSH 1 
        $PUSH .lpbak
        $PUSH .for
    >

    DEFINE  $ENDFOR (%BACK, %END) <
        $MUSTBE <.for> 
            IFE <.mbflag-.false>,<
                PRINTX STRUC2 ERROR: ENDFOR was expecting FOR.
                END  
            >
      %BACK:  exp 0
        $RBACK
      %END:
        $RFORX
    > 

    DEFINE  $CASE <
        $PUSH 0                     ; Number of structure end jumps to resolve.
        $PUSH 0                     ; Link to the next WHEN or DEFAULT clause.
        $PUSH .case1                ; Open a virgin CASE activation frame.
    >

    DEFINE  $WHEN (UCOND, %T, %F, %ENTRY, %END) <
        $MUSTBE <.case1,.case2> 
            IFE <.mbflag-.false>,<
                PRINTX STRUC2 ERROR: WHEN was expecting CASE or WHEN.
                END  
            >

            ; Frame type .case1 has never seen a WHEN clause before now. The chain
            ;   of WHEN clauses begins here with a special WHEN which does not
            ;   have to guard a previous WHEN's branch to structure end point.
        IFE <.getval-.case1>,<
        $LOGIC %T, %F     
        $PARSE UCOND
          %F:    exp 0              ; 'False' continues to the next WHEN clause.
          %T:                       ; 'True' runs the code body in this WHEN.
            $POP
            $PUSH %F
            $PUSH .case2            ; Signal 'non-virgin' WHEN mode.
        >

            ; Frame type .case2 knows that the chain of WHEN clauses should continue,
            ;   and so provides a jump to structure end for the previous WHEN.
        IFE <.getval-.case2>,<
          %END:   exp 0             ; Allow preceding WHEN to get to structure end.
            $POP
            .temp2=.getval          ; Remember the forward link to the next clause.
            $POP
            .temp3=.getval          ; Get the current number of jumps to resolve...
            .temp3=.temp3+1         ; ...and increment it.
            $PUSH %END              ; Push another end jump for later resolution.
            $PUSH .temp3            ; Push the new jump count.
            $PUSH .temp2            ; Restore the previous 'false' link.
          %ENTRY:                   ; Flow from 'false' brach in previous WHEN.
            $RFORW
            $LOGIC %T, %F
            $PARSE UCOND
          %F:  exp 0                ; 'False' continues to the next WHEN clause.
          %T:                       ; 'True' runs the code body in this WHEN.
            $PUSH %F
            $PUSH .case2            ; The WHEN chain continues...
        >
    >

    DEFINE  $DEFAULT (%ENTRY, %END) <
            ; DEFAULT is just a WHEN without a logic block. DEFAULT must see a 
            ;   previous WHEN.
        $MUSTBE <.case2> 
            IFE <.mbflag-.false>,<
                PRINTX STRUC2 ERROR: DEFAULT was expecting WHEN.
                END  
            >
          %END:   exp 0             ; Allow preceding WHEN to get to structure end.
            $POP
            .temp2=.getval          ; Remember the forward link to the next clause.
            $POP
            .temp3=.getval          ; Get the current number of jumps to resolve...
            .temp3=.temp3+1         ; ...and increment it.
            $PUSH %END              ; Push another end jump for later resolution.
            $PUSH .temp3            ; Push the new jump count.
            $PUSH .temp2            ; Restore the previous 'false' link.
          %ENTRY:                   ; Flow from 'false' brach in previous WHEN.
            $RFORW
            $PUSH 0                 ; We need a fake forward link here.
            $PUSH .case3            ; The WHEN chain ends.
    >

    DEFINE  $ENDCASE <
        $MUSTBE <.case1,.case2,.case3>
            IFE <.mbflag-.false>,<
                PRINTX STRUC2 ERROR: ENDCASE was expecting CASE, WHEN, or DEFAULT.
                END 
            >
        $POP                        ; Pop any remaining forward links.
        $RFORX                      ; Resolve all structure exit jumps.
    >

    DEFINE  $BREAK (UCOND, %T, %F) <
        $MUSTBE <.while,.repeat,.for> 
            IFE <.mbflag-.false>,<
                PRINTX STRUC2 ERROR: BREAK was expecting WHILE, REPEAT, or FOR.
                END  
            >
        $LOGIC %T, %F
        $PARSE UCOND
      %T:
      %F:   exp 0
            ; Edit the current loop activation frame.
            .temp1=.getval          ; Remember the frame activation code.
        $POP
            .temp2=.getval          ; Pop the loopback address.
        $POP
            .temp3=.getval          ; Pop the old count of structure exit jumps.
        $PUSH %T                    ; Insert another structure exit jump to resolve...
            .temp3=.temp3+1         ;     ...and count it.
        $PUSH .temp3                ; Store the new count of structure exit jumps.
        $PUSH .temp2                ; Restore loopback address.
        $PUSH .temp1                ; Restore loop frame activation code.
    >

    DEFINE  $CONTINUE  (UCOND, %T, %F) <
        $MUSTBE <.while,.repeat,.for>
            IFE <.mbflag-.false>,<
                PRINTX STRUC2 ERROR: CONTINUE was expecting WHILE, REPEAT, or FOR.
                END  
            >
            .temp1=.getval          ; Remember the frame activation code.
        
        $LOGIC %T, %F
        $PARSE UCOND
      %T:
        $RBACK                      ; Resolve loopback address for CONTINUE.
        $PUSH .getval               ; Restore loopback address.
        $PUSH .temp1                ; Restore loop frame activation code.
      %F:
    >


            END

